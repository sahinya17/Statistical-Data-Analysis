---
title: "ETC5242Assignment"
author: "Sahinya Akila"
date: "9/4/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(survival)
library(survminer)
library(kableExtra)
library(knitr)
library(ggplot2)
## Remove the line break in the file name!
churn_dat <- read_csv("https://raw.githubusercontent.com/square/pysurvival/master/pysurvival/datasets/churn.csv")
churn_dat <- churn_dat %>% filter(months_active > 0) %>% select(c(company_size, months_active, churned)) %>% na.omit()
```

```{r}
km_model <- function(time, event){
  dataset <- data_frame(time, event)
  
  km_data <- dataset %>% 
    group_by(time, event) %>% 
    summarise(died = n()) %>% 
    ungroup() %>% 
    mutate(risk = nrow(dataset) - accumulate(died, `+`) + died) %>% 
    filter(event == 1) %>% 
    mutate(probability = 1 - died/risk,
           survival = accumulate(probability, `*`))
  return(km_data %>% select(time, survival))
}

km_survive <- km_model(churn_dat$months_active, churn_dat$churned) 

km_survive %>% 
  ggplot(aes(time, survival)) +
  geom_step()
```


```{r}
company_km_model <- data.frame(time = double(), survival = double(), company_size = character())
for(size in unique(churn_dat$company_size)){
  filtered <- churn_dat %>% filter(company_size == size)
  final_model <- km_model(filtered$months_active, filtered$churned) %>% mutate(company_size = size)
  company_km_model <- rbind(company_km_model, final_model)
}

company_km_model %>% 
  ggplot(aes(time, survival)) +
  geom_step() +
  facet_wrap(~company_size)
```


# Question 2


## Compute the Kaplan-Meir curve and use this to estimate the median churn time.

```{r}
fit <- survfit(Surv(months_active, churned) ~ company_size,
                  data = churn_dat)

g2 <- ggsurvplot(fit,conf.int = FALSE)

g2$plot +
  labs(x = "Months Active",
       title = "Kaplan-Meir curve for each company size") +
  theme(legend.position="bottom") 
```


```{r}
median_function <- function(fit){
  index <- which.min(abs(fit$surv - 0.5))
  median <- fit$time[index]
  return(median)
}
```


```{r}

for (size in unique(churn_dat$company_size)){
  temp_data <- churn_dat %>% filter(company_size == size)
  name <- size
  assign(name, survfit(Surv(months_active, churned) ~ company_size, data = temp_data))
}

```

```{r}
company_median <- data_frame(company_size = unique(churn_dat$company_size), median = c(NA, NA, NA, NA, NA))

for (i in 1:length(company_median$company_size)){
  company_median$median[i] <- median_function(get(company_median$company_size[i]))
}

company_median %>%
  knitr::kable(
  caption = "Medians for different company sizes") %>%
  kable_styling(c("hover", "striped"))
```

The table above demonstrates the median churn time estimated for different company size.
- Company size of 1-10 have the highest estimated median of 7 months.
- Company size of 100-250 have the lowest estimated median of 4 months.
- The rest of the company sizes have the same estimated median of 5 months.

## Use a non-parametric bootstrap to construct 90% confidence intervals for the median of each company size


```{r}
bootstrapmedian <- function(df_median, df){
  bootstrap <- tibble(experiment = rep(1:1000, each = nrow(df)),
                        ind = sample(1:nrow(df), size = nrow(df)*1000, replace = TRUE),
                        timestar = df$months_active[ind],
                        churnstar = df$churned[ind])
  
  bias <- bootstrap %>%
    group_by(experiment) %>%
    summarise(delta = median_function(df_median) - median_function(survfit(Surv(timestar, churnstar) ~ experiment))) %>% na.omit()

  ci <- median_function(df_median) + quantile(bias$delta, c(0.05, 0.95))
  
  return(ci)
}
```

```{r}
company_median_ci <- data_frame(company_size = unique(churn_dat$company_size), median = c(NA, NA, NA, NA, NA), lci = c(NA, NA, NA, NA, NA), uci = c(NA, NA, NA, NA, NA))

for (i in 1:length(company_median_ci$company_size)){
  ci <- bootstrapmedian(get(company_median_ci$company_size[i]), churn_dat %>% filter(company_size == company_median_ci$company_size[i]))
  company_median_ci$median[i] <- median_function(get(company_median_ci$company_size[i]))
           company_median_ci$lci[i] <- ci[1]
           company_median_ci$uci[i] = ci[2]
}
company_median_ci %>%
  knitr::kable(
  caption = "estimated mean under 90% CI") %>%
  kable_styling(c("hover", "striped"))
```

## Make a plot that shows that estimate of the median and the corresponding confidence interval on the same axes

```{r}
ggplot(company_median_ci,
       aes(x = company_size,
           y = median,
           colour = company_size)) + 
  geom_errorbar(aes(ymax = uci, ymin = lci)) +
  geom_point() +
  theme_bw() +
  labs(x = "Company Size",
       y = "Estimated Median Churn Time",
       title = "estimated mean under 90% CI")
```
Q3
- Use a nonparametric bootstrap to re-sample the data and construct 90% confidence intervals for the survival curve at each time.

```{r}
mean_ci(Surv(churn_dat$months_active, churn_dat$churned)) %>%
  knitr::kable(
  caption = "Minimum and Maximum value in the survival curve") %>%
  kable_styling(c("hover", "striped"))
```

```{r}
is_in_ci <- function(max_y, true_max, n, n_sim = 1000) {
bootstrap <- tibble(experiment = rep(1:n_sim,
each = n),
ystar = runif(n * n_sim, 0, max_y))
bias <- bootstrap %>%
group_by(experiment) %>%
summarise(delta = max_y - max(ystar))
int <- max_y + quantile(bias$delta, c(0.05, 0.95))
return((true_max > int[1]) & (true_max < int[2]))
}
```


Check the coverage
```{r}
true_max <- 2.32718

experiments <- tibble(experiment = rep(1:1000,
each = 100),
draw = runif(100*1000,0,true_max))
test <- experiments %>%
group_by(experiment) %>%
summarise(max_y = max(draw)) %>%
mutate(is_in = map_dbl(max_y,
~is_in_ci(.x, true_max, 100)))
mean(test$is_in)
```

# Question 3

## Choose company size of 50-100
```{r}
q3_company <- churn_dat %>% 
  filter(company_size == "50-100")

q3_fit <- survfit(Surv(months_active, churned) ~1,
                  data = q3_company)
```

## Use a nonparametric bootstrap to re-sample the data and construct 90% confidence intervals for the survival curve at each time.

```{r}
bootstrap_time <- tibble(experiment = rep(1:1000, each =672),
                        ind = sample(1:672, size = 672*1000, replace = TRUE),
                                    months_active = q3_company$months_active[ind],
                                    churned = q3_company$churned[ind])
bias_time <- bootstrap_time %>% 
  group_by(experiment) %>% 
  summarise(delta = q3_fit$surv - survfit(Surv(months_active, churned) ~1)$surv)

lowerCIs <- q3_fit$surv + quantile(bias_time$delta, 0.05)
upperCIs <- q3_fit$surv + quantile(bias_time$delta, 0.95)
```

```{r}
Month <- c(1:11)

time_50_100_CIs <- data.frame(Month, q3_fit$surv, lowerCIs, upperCIs) %>%
  rename("Probability" = q3_fit.surv, "Lower Confidence Interval" = lowerCIs, "Upper Confidence Interval" = upperCIs) 

kable(time_50_100_CIs, 
      caption = "90% confidence intervals for the survival curve at each time for company size 50-100") %>% 
  kable_styling(c("hover", "striped"))
```

## Compute simultaneous coverage for the entire survival function.



Q4

log-rank test
```{r}
q4_comp <- churn_dat %>%
 mutate(comp_hyp = case_when(company_size == "50-100" ~ 1, company_size== "100-250" ~ 2, TRUE ~ 0))

q4_comp <- q4_comp %>%
  filter(comp_hyp == 1| comp_hyp == 2)
```

```{r}
survdiff(Surv(months_active, churned) ~ comp_hyp, data=q4_comp)
```


```{r}
treatment <- q4_comp$churned
outcome <- q4_comp$months_active

#Difference in means
original <- diff(tapply(outcome, treatment, mean))
mean(outcome[treatment==1])-mean(outcome[treatment==0])

#Permutation test
permutation.test <- function(treatment, outcome, n){
  distribution=c()
  result=0
  for(i in 1:n){
    distribution[i]=diff(by(outcome, sample(treatment, length(treatment), FALSE), mean))
  }
  result=sum(abs(distribution) >= abs(original))/(n)
  return(list(result, distribution))
}

test1 <- permutation.test(treatment, outcome, 10000)
hist(test1[[2]], breaks=50, col='grey', main="Permutation Distribution", las=1, xlab='')
abline(v=original, lwd=3, col="red")

test1[[1]]


#Compare to t-test
t.test(outcome~treatment)
```

